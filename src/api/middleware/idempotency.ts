import { Request, Response, NextFunction } from 'express';
import { prisma } from '../../lib/prisma.js';
import { logger } from '../../utils/logger.js';

const IDEMPOTENCY_EXPIRY_HOURS = 24;

/**
 * Idempotency Middleware
 *
 * Prevents duplicate operations by tracking idempotency keys.
 * If a request with the same key was already processed, returns the cached response.
 *
 * Usage: Include 'Idempotency-Key' header in POST/PATCH/PUT/DELETE requests.
 *
 * The key should be a unique identifier generated by the client (e.g., UUID).
 */
export async function idempotencyMiddleware(
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> {
  // Only apply to state-changing methods
  if (!['POST', 'PATCH', 'PUT', 'DELETE'].includes(req.method)) {
    return next();
  }

  const idempotencyKey = req.headers['idempotency-key'] as string;

  // Skip if no key provided (idempotency is optional for some endpoints)
  if (!idempotencyKey) {
    return next();
  }

  const organizationId = req.organizationId;

  // Require organization context for idempotency
  if (!organizationId) {
    return next();
  }

  try {
    // Check for existing record with this key
    const existing = await prisma.idempotencyRecord.findUnique({
      where: {
        organizationId_idempotencyKey: {
          organizationId,
          idempotencyKey,
        },
      },
    });

    if (existing) {
      // Check if the request path matches
      if (existing.requestPath !== req.path || existing.requestMethod !== req.method) {
        res.status(422).json({
          error: {
            code: 'IDEMPOTENCY_KEY_REUSED',
            message: 'Idempotency key was already used for a different request',
          },
        });
        return;
      }

      logger.info('Returning cached idempotent response', {
        idempotencyKey,
        organizationId,
        path: req.path,
      });

      // Return cached response
      res.status(existing.statusCode).json(existing.responseData);
      return;
    }

    // Store the idempotency key for response capture
    req.idempotencyKey = idempotencyKey;

    // Intercept response to cache it
    const originalJson = res.json.bind(res);
    let responseCaptured = false;

    res.json = function (data: unknown) {
      // Only capture once
      if (responseCaptured) {
        return originalJson(data);
      }
      responseCaptured = true;

      // Store the response for future duplicate requests
      prisma.idempotencyRecord
        .create({
          data: {
            organizationId,
            idempotencyKey,
            requestPath: req.path,
            requestMethod: req.method,
            statusCode: res.statusCode,
            responseData: data as object,
            expiresAt: new Date(Date.now() + IDEMPOTENCY_EXPIRY_HOURS * 60 * 60 * 1000),
          },
        })
        .then(() => {
          logger.debug('Cached idempotent response', {
            idempotencyKey,
            organizationId,
            statusCode: res.statusCode,
          });
        })
        .catch((err) => {
          // Non-critical error - log but don't fail the request
          logger.error('Failed to store idempotency record', {
            idempotencyKey,
            organizationId,
            error: err instanceof Error ? err.message : 'Unknown error',
          });
        });

      return originalJson(data);
    };

    next();
  } catch (error) {
    logger.error('Idempotency middleware error', {
      idempotencyKey,
      organizationId,
      error: error instanceof Error ? error.message : 'Unknown error',
    });
    next(error);
  }
}

/**
 * Require Idempotency Key Middleware
 *
 * Enforces idempotency key requirement for specific endpoints.
 * Use this for critical state-changing operations.
 */
export function requireIdempotencyKey(
  req: Request,
  res: Response,
  next: NextFunction
): void {
  if (!['POST', 'PATCH', 'PUT', 'DELETE'].includes(req.method)) {
    return next();
  }

  const idempotencyKey = req.headers['idempotency-key'];

  if (!idempotencyKey) {
    res.status(400).json({
      error: {
        code: 'IDEMPOTENCY_KEY_REQUIRED',
        message: 'Idempotency-Key header is required for this operation',
      },
    });
    return;
  }

  next();
}

/**
 * Cleanup Expired Idempotency Records
 *
 * Should be called periodically (e.g., via cron job) to remove expired records.
 */
export async function cleanupExpiredIdempotencyRecords(): Promise<number> {
  const result = await prisma.idempotencyRecord.deleteMany({
    where: {
      expiresAt: {
        lt: new Date(),
      },
    },
  });

  logger.info('Cleaned up expired idempotency records', {
    deletedCount: result.count,
  });

  return result.count;
}
